Базовый синтаксис XPath для парсинга элементов:

1) * — Выбрать любой элемент.

2) [] — Найти конкретный элемент. Пример: //li[1] имя_узла — Выбирает все узлы с указанным именем узла. Пример: div, p и т.д.

3) / — Ищет от корневого узла html

4) // — Ищет узлы в документе от текущего узла, который соответствует выбору, независимо от того, где они находятся

5) . — Ищет текущий узел

6) .. — Ищет родителя текущего узла

7) @ — Ищет нужный атрибут. Пример: //p[@value="2008"]

Общие функции XPath
Язык XPath имеет набор встроенных функций, которые позволяют осуществлять различные операции с XML-документами. Вот некоторые из основных функций XPath:

1) text() - возвращает текстовое содержимое элемента.

2) count() - возвращает количество элементов, соответствующих указанному выражению.

3) normalize-space() - удаляет лишние пробелы из строки и заменяет последовательности пробелов на одиночные пробелы.

4) starts-with(x,y) - проверяет, начинается ли строка с x-y.

5) contains(x,y) - проверяет, содержит ли строка x-y.

6) last() - возвращает последнюю позицию элемента в выборке.

7) position() - возвращает позицию текущего элемента в выборке.

8) name() - возвращает имя текущего элемента.

9) sum() - суммирует значения элементов выборки.

10) string() - преобразует узел в строку.

11) lower-case() - преобразует текст в нижний регистр.

12) @attribute - выбирает значение указанного атрибута.

13) concat() - объединяет две или более строки.

14) string-length() - возвращает длину строки.

15) substring() - возвращает подстроку из строки, начиная с указанной позиции.

Оси XPath
Ось в XPath - это специальная концепция, которая используется для указания направления движения при поиске элементов в документе. Оси позволяют выбирать элементы, которые относятся к определенным отношениям с другими элементами в дереве XML или HTML.

В XPath есть несколько осей, которые можно использовать при создании выражений:

1) child::note — Выбирает все узлы note, которые являются прямыми потомками текущего узла

2) attribute::date — Выбирает атрибут date текущего узла

3) child::* — Выбирает всех прямых потомков текущего узла

4) attribute::* — Выбирает все атрибуты текущего узла

5) child::text() — Выбирает все текстовые узлы текущего узла

6) child::node() — Выбирает всех прямых потомков текущего узла

7) descendant::note — Выбирает всех потомков note текущего узла

8) ancestor::note — Выбирает всех предков note текущего узла

9) ancestor-or-self::note — Выбирает всех предков note текущего узла, а также сам текущий узел, если это узел note

10) child::*/child::heading — Выбирает всех прямых потомков прямых потомков (“внуков") heading текущего узла

11) last() — Выделяет последний элемент в дереве.

Предикаты (Коллекции)
Предикаты — конструкции, которые используются для фильтрации элементов и выбора конкретных элементов с помощью определенных условий.

Вот несколько примеров использования предикатов в XPath для :

1) //a — Выберите все элементы в документе

2) //a[@class='active'] — Выберите все элементы, у которых атрибут class равен "active"

3) //input[@type='checkbox'] — Выберите все элементы input, у которых атрибут type равен "checkbox"

4) //input[@type='text'] — Выберите все элементы input с атрибутом type равным "text"

5) //p[contains(text(), 'Lorem')] — Выберите все элементы, у которых текст содержит слово "Lorem"

6) //div[count(p) > 3] — Выберите все элементы, у которых количество дочерних элементов больше 3

7) //a[starts-with(@href, 'https://')] — Выберите все элементы, у которых атрибут href начинается с "https://"

8) //input[matches(@value, '^\d+$')] — Выберите все элементы input, у которых атрибут value содержит только цифры

9) //p[@value="01/2008"] — Выбирает все элементы p, у которых есть атрибут value со значением "01/2008"

10) //p[@value] — Выбирает все элементы p, у которых есть атрибут value

11) //p/text() — Выделит все текстовые узлы внутри всех элементов p

12) //div[not(p)] — Выберите все элементы, у которых не существует дочернего элемента

13) /div/p[position()<3] — Выбирает первые два элемента p, которые являются прямыми потомками элемента div

14) //tag[position()=1] — Выбирает первый элемент с тегом "tag"

15) /div/ul/li[1] — Выбирает первый элемент li, который является прямым потомком элемента ul в div

16) //li[a] — Выделяет элементы li, в которых есть элемент a

17) //li[last()] — Выделяет последний элемент li в документе

18) //a | //h2 - Выделить все элементы a и h2 с помощью оператора объединения |

19) //tag[@value > 9] — Получить узлы tag, value которых больше 9-ти.

20) //div[note[@value > 9]]/а — Получить только имена узлов, value которых больше 9-ти

21) //div[4]/h2[text() = "Текст"] — Выделит четвертый элемент div, h2 которого содержит слово: Текст

22) /div/note[last()] — Выбирает последний элемент note, который является прямым потомком элемента div

23) /div/note[last()-1] — Выбирает предпоследний элемент note, который является прямым потомком элемента div

24) //*[@id] — Выберите все элементы с атрибутом id

25) //div[contains(@class, 'content')]/p — Выберите все элементы, которые являются дочерними элементами с классом "content"

26) //img[contains(@src, 'logo')] — Выберите все элементы , у которых атрибут src содержит слово "logo"

27) //*[@href[contains(text(), '.pdf')]] — Выберите все элементы со значением атрибута href, оканчивающимся на .pdf

28) //*[@data-toggle='modal'] — Выберите все элементы с атрибутом data-toggle и значением "modal"

29) //tag[@attribute>5] — Выбирает все элементы с тегом "tag" и атрибутом "attribute", значение которого больше 5

30) //tag[@attribute="value"] — Выбирает все элементы с тегом "tag" и атрибутом "attribute" со значением "value"

Формулы по извлечению HTML атрибутов которые будут полезны СЕОшникам
1) //@href — Извлечь все ссылки

2) //a[starts-with(@href,'mailto')]/@href — Получить ссылки, которые содержат “mailto” (email адрес)

3) //a[contains(@href,'tel:')]/@href — Получить все телефоны

4) //img/@src — Получить все URL адреса картинок

5) //img[contains(@class,'name-class')]/@src — Получить все URL адреса источников изображений с именем класса

6) //div[@class='class'] — Получить элементы в тегах с определенным классом, указанным в кавычках

7) count(//h2) — Посчитать количество элементов на странице

8) //*[@itemtype]/@itemtype — Извелчь какие типы микроразметок есть на странице

9) //*[@itemprop='price']/@content — Узнать значение поля свойства разметки

10) //iframe[contains(@src,'https://www.youtube.com/')]/@src — Найти ссылки на все видео с ютуба

11) //table[@class='product-table']//td/text() — Извлечь текст всех ячеек таблицы с классом "product-table"

12) //td[contains(text(),'Weight')]/following-sibling::td — Извлечение данных из ячеек таблиц

13) contains(//meta[@name='description']/@content, 'таргетированное-ключевое-слово') — Проверяет наличие ключевого слова в мета теге

14) //link[@rel=’amphtml’]/@href — Получить URL-адрес AMP

15) //form[*]/input[@type='text']/@name — Имена всех текстовых полей внутри форм



XPath и как правильного его готовить
1) Удаляйте лишние пробелы в строке с помощью функции normalize-space().

Код <div class="btn">Войти через Google</div>

Плохая практика //[text()=’Войти через Google’]

Хорошая практика //[normalize-space(text())=’Войти через Google’]

Почему: Последний селектор нивелирует ошибки в верстке, связанные с пробелами. Например, это спасет в подобной ситуации:

<div class="btn"> Войти через Google </div>

<div class="btn"> Войти     через  Google </div>

2) Не пишите селекторы по полному совпадению наименования классов.

Код <div class="large red Menu_mainLink">Услуги/div>

Плохая практика //div[@class=’large red Menu_mainLink’]

Хорошая практика //div[contains(@class, ’Menu_mainLink’)]

Почему: Буквально завтра заказчик может поменять дизайн и вместо класса red использовать blue, или добавить/удалить какой-нибудь из классов. Если вы не хотите делать лишнюю работу лучше предусмотреть устойчивость селектора к подобным изменениям. А сделать это можно, отказавшись от явного указания на наименование класса.

3) Не используйте фильтры по номерам, если можно этого избежать.

Код: 

<div class="large red Menu_mainLink">

<a class="Menu_item__5wCCA">Услуги</a>

<a class="Menu_item__5wCCB">Афиша</a>

<a class="Menu_item__5wCCC">Карта</a>

</div>

Пишем селектор к элементу <a>Карта</a>

Плохая практика (//div/a)[3]

Хорошая практика //a[normalize-space(.)=’Карта’]

Почему: Количеству пунктов в меню и их порядок могут поменяться по мере развития сайта. Правильно составленный селектор будет гораздо устойчивее и окажется независим от количества пунктов в меню. 

”Живой” пример “плохого” селектора: 

//[@id=’login_form’]/div[2]/div/table/tbody/tr[2]/td[2]/input

4) Используйте один селектор для множества элементов.

Снова обратимся к коду из пункта №3. Если посмотреть внимательно, то один XPath селектор можно использовать для каждого пункта меню, достаточно обернуть его в функцию. 

Плохая практика (писать почти одинаковые селекторы к каждому пункту): 

service=driver.find_element_by_xpath(f”//[normalize-space(.)=‘Услуги’]”

affiche=driver.find_element_by_xpath(f”//[normalize-space(.)=‘Афиша’]”

map=driver.find_element_by_xpath(f”//[normalize-space(.)=‘Карта’]”

Хорошая практика: 

def get_menu_item(text):

 element=driver.find_element_by_xpath(f”//[normalize-space(.)=’{text}’]”

 return element

service = get_menu_item(‘Услуги’)

affiche = get_menu_item(‘Афиша’)

map = get_menu_item(‘Карта’)

Почему: Если не использовать общий селектор, то работы по написанию становится больше. А при грамотном оформлении функции получается удобно читаемый/редактируемый код, возрастает скорость его написания.

5) Используйте поиск по вложенному тексту(.)

Для тегов <h1>-<h6>, <a>, <button>, <li>, <td> по возможности необходимо использовать поиск по вложенному тексту (.), а не по text().

Код:

<button jsname="pzCKEc" class="EzVRq" aria-controls="dEjpnf" aria-haspopup="true">Настройки</button>

Плохая практика //button[normalize-space(text())='Настройки']

Хорошая практика: //button[normalize-space(.)='Настройки']

Почему: Разработчик в любой момент может обернуть текст внутри в какой-нибудь <span>, и тогда поиск по text() не будет работать. Бывает, что фреймворки не могут кликнуть по вложенному тегу, иногда это приводит к ошибкам перехвата клика элементом уровнем выше. Если же искать по вложенному тексту, все эти проблемы перестают быть опасными.

6) Магия XPath для динамического контента

Эта ситуация еще интереснее. Предположим, перед вами стоит задача, определить наличие текста на странице. Но текст при этом — динамический. То есть элемент загружается сразу, а текст в нем немного позже. 

Плохая практика: 

time.sleep(5)  # Принудительная пауза 5 секунд

//div[contains(@class,'card')][normalize-space(.)='Оглавление']

Хорошая практика: использование методов ожидания элемента в дереве DOM по “правильному” селектору, например вот такому: 

//div[contains(@class,'card')][not(normalize-space(.)='')]

Система будет ждать, пока селектор не станет актуальным, т.е. в нашем случае, пока не появится текст.

Еще один пример правильного селектора для работы с динамическим текстом элемента. Здесь используем “|” (или):

//[normalize-space(text())='Войти'] | //[normalize-space(text())='Авторизоваться']

Почему: Использование обычных пауз в коде не решает проблемы, так как сводится к лотерее - успеет или не успеет загрузиться. Методы ожидания элемента делают работу селектора на 100% независимой от скорости появления текста.

7) Используйте отношения элементов DOM

Мы уже говорили выше о возможности XPath двигаться по дереву DOM вверх и вниз. Но это не единственный пример хорошей практики использования отношений элементов.

Представьте, что у вас страница с множеством одинаковых блоков, в которых может содержаться множество одинаковых элементов. XPath позволяет определить конкретный блок по какому-либо признаку и далее осуществлять поиск элементов только в нем. 

Код:

<form-field><input id=”123”>...</input><a>Скачать</a>

</form-field>

<form-field><input id=”abc”>...</input><a>Скачать</a>

</form-field>

<form-field><input id=”xyz”>..</input><a>Скачать</a>

</form-field>

Плохая практика:

//input[@id='123']/../../../..//form-field//*[normalize-space(text())='какой-то текст']

Хорошая практика:

 //form-field[//input[@id='abc']]//*[normalize-space(text())='Скачать']

